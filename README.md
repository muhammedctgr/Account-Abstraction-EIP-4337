## Account Abstraction EIP-4337

**Understanding Account Abstraction: Revolutionizing Blockchain User Experience.**

Account Abstraction (AA) is a pivotal development in the blockchain space, particularly within the Ethereum ecosystem through EIP-4337. This project delves into the intricacies of Account Abstraction, exploring the user experience challenges it addresses, its core mechanics, and contrasting Ethereum's implementation with native AA solutions like that of zkSync. While the concept can be challenging, understanding it unlocks a new paradigm for interacting with decentralized applications.

**What is Account Abstraction? The Core Shift in Transaction Validation.**

Account Abstraction fundamentally redefines how transactions are authorized and validated on a blockchain. The core idea is to move away from a rigid system where transaction validity is solely tied to an Elliptic Curve Digital Signature Algorithm (ECDSA) signature generated by a private key. Instead, AA allows for arbitrary validation logic defined within a smart contract.

EoAs are now smart contracts. That's all account abstraction is.

But what does that mean?

Right now, every single transaction in web3 stems from a single private key. 

> account abstraction means that not only the execution of a transaction can be arbitrarily complex computation logic as specified by the EVM, but also the authorization logic.

- [Vitalik Buterin](https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020)
- [EntryPoint Contract v0.6](https://etherscan.io/address/0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789)
- [EntryPoint Contract v0.7](https://etherscan.io/address/0x0000000071727De22E5E9d8BAf0edAc6f37da032)
- [zkSync AA Transaction Flow](https://docs.zksync.io/build/developer-reference/account-abstraction.html#the-transaction-flow)

To put it simply:

Traditional Model: Private Key = Wallet. The private key is the ultimate authority.

Account Abstraction Model: Programmable Logic = Wallet. The authority and validation rules are defined by the code within a smart contract account.

This shift means that instead of the blockchain protocol itself dictating that only a private key signature can authorize a transaction from an Externally Owned Account (EOA), the account itself (now a smart contract) dictates the conditions under which a transaction is considered valid.

This programmable validity opens up a wealth of possibilities:

Social Login/Recovery: Users could authorize transactions using familiar credentials like a Google account, GitHub, or even biometrics, abstracting away the need to directly manage private keys.

Multi-signature (Multi-sig) Wallets: Require approvals from multiple parties (e.g., three out of five authorized signers) before a transaction is executed.

Spending Limits: Enforce daily, weekly, or per-transaction spending caps directly at the account level.

Time Locks: Permit transactions only during specific windows (e.g., business hours) or after a certain delay.

Parental Controls: A wallet for a minor could be configured such that transactions initiated by the child require approval from a parent's account before execution.

Gas Abstraction: Solving the "Need Gas" Problem with Paymasters
A significant corollary of programmable validation is gas abstraction. Because the account's validation logic is flexible, AA enables mechanisms where someone other than the user can pay for their transaction gas fees.

This directly addresses the friction point where users need native tokens for every interaction. With AA, a dApp developer, a project, or a dedicated third-party service (known as a "Paymaster") can sponsor transactions. The user can interact with a dApp without needing to first acquire and hold ETH (or the L2's native token) specifically for gas.

How Account Abstraction Works: EIP-4337 vs. Native Implementations
The implementation of Account Abstraction varies, leading to different levels of complexity. There are two primary approaches:

Ethereum (EIP-4337): This standard implements Account Abstraction on top of the existing Ethereum protocol without requiring core consensus changes. It relies on a higher-level infrastructure, including a special smart contract (EntryPoint.sol) and an alternative mempool for user operations. EIP-4337 went live on Ethereum mainnet on March 1st, 2023.

Native Account Abstraction (e.g., zkSync): Some Layer 2 solutions and newer blockchains build Account Abstraction directly into their core protocol. This often leads to a more streamlined and integrated experience.

Traditional Ethereum Transaction Flow (Recap)
Before diving into EIP-4337, let's quickly recap the traditional Ethereum transaction flow:

Off-Chain: A user, using a wallet like MetaMask, signs transaction data with their private key. This signature, along with the transaction details and gas payment, is prepared.

On-Chain: The signed transaction is broadcast to an Ethereum node.

The node validates the transaction (including the signature and sufficient gas) and, if valid, adds it to its local mempool.

Miners/validators pick transactions from the mempool to include in a new block, which is then added to the blockchain.

Account Abstraction on Ethereum via EIP-4337: A Detailed Look
EIP-4337 introduces a new, parallel system for transaction processing that leverages smart contracts to achieve account abstraction. The flow involves several key components:

Deploy a Smart Contract Wallet (SCW):
Instead of relying solely on an EOA, the user interacts through a Smart Contract Wallet (SCW). This SCW is a smart contract deployed on the blockchain (e.g., MyNewAccount.sol) that contains the custom validation logic. This logic dictates what constitutes a valid authorization for that specific account â€“ it could be a signature from a specific key (mimicking an EOA), a multi-sig condition, or a check against an off-chain authentication service.

Construct and Send a "UserOperation" (UserOp) to the Alt Mempool:
When a user wants to perform an action (e.g., send tokens, interact with a DeFi protocol), their wallet interface (now AA-aware) constructs a UserOperation (UserOp) object. This is not a standard Ethereum transaction. The UserOp struct, defined in the EIP-4337 specification, includes fields such as:

sender: The address of the user's SCW.

nonce: A sequence number to prevent replay attacks.

callData: The actual operation to be executed by the SCW (e.g., the function call and parameters for an ERC20 transfer).

Gas-related fields (callGasLimit, verificationGasLimit, preVerificationGas, maxFeePerGas, maxPriorityFeePerGas).

paymasterAndData: Optional data for specifying a Paymaster to sponsor gas fees.

signature: The signature that satisfies the SCW's custom validation logic.

This UserOp, signed according to the SCW's rules, is then sent to a separate, off-chain peer-to-peer network known as the Alternative Mempool (Alt Mempool). This mempool is specifically for UserOps and operates independently of Ethereum's main transaction mempool.

Bundlers Process UserOps:
Specialized nodes participating in the Alt Mempool network are called Bundlers. Their role is to:

Listen for UserOps in the Alt Mempool.

Validate each UserOp by simulating its validation logic against the target SCW.

Bundle multiple valid UserOps together into a single, standard Ethereum transaction.

Crucially, the Bundler pays the gas fee for this bundled Ethereum transaction sent to the main Ethereum network. They are later compensated either by the SCWs themselves or by Paymasters.

Bundler Calls the EntryPoint.sol Contract:
The Bundler submits this bundled transaction by calling a specific function (typically handleOps) on a single, globally deployed smart contract called EntryPoint.sol. This contract (developed and maintained by the eth-infinitism group, with support from the Ethereum Foundation) acts as the central orchestrator for EIP-4337. Its canonical address (e.g., 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789 for v0.6/v0.7) is known and trusted.

The EntryPoint.sol contract then performs its own set of critical operations:

It iterates through each UserOp in the bundle.

For each UserOp, it first verifies the UserOp's signature and other parameters by calling a validation function on the user's SCW (e.g., validateUserOp).

It checks if the SCW has enough funds to pay the Bundler for gas, or if a specified Paymaster has agreed to cover the costs.

Smart Contract Wallet Executes the Transaction:
If the validation step in EntryPoint.sol (which involves calling the SCW's validation logic) is successful, EntryPoint.sol then calls another function on the user's SCW to execute the actual intended operation. This is where the callData from the UserOp is executed (e.g., making a swap on Uniswap, or lending assets on Aave).

Importantly, during this execution phase, the msg.sender for the target dApp interaction will be the address of the user's SCW, not the Bundler or the EntryPoint contract. This ensures that from the perspective of other smart contracts, the SCW is the true originator of the action.
The results of these operations are then recorded on the Ethereum blockchain.

Optional EIP-4337 Add-ons:

Signature Aggregators: EIP-4337 supports the use of Signature Aggregator contracts. These contracts can be used by EntryPoint.sol to validate aggregated signatures (e.g., BLS signatures). This is particularly useful for multi-sig SCWs or for batching operations, as it can significantly reduce gas costs by verifying multiple signatures in a single operation.

Paymasters: As mentioned, a Paymaster is a smart contract that can agree to pay the gas fees for a UserOp. The UserOp can specify a Paymaster contract and include data that the Paymaster requires for its validation (e.g., a signature from the dApp sponsoring the transaction). If a Paymaster is used and successfully validates, it reimburses the Bundler via the EntryPoint.sol contract. If no Paymaster is used, the user's SCW must have sufficient native token balance, which EntryPoint.sol will transfer to the Bundler as compensation.

The EIP-4337 flow, while powerful, involves several interconnected components: the user's SCW, the UserOp object, the Alt Mempool, Bundlers, and the central EntryPoint.sol contract.

Native Account Abstraction: The zkSync Example
Blockchains with native Account Abstraction, such as zkSync Era, integrate AA principles directly into their core protocol, often resulting in a simpler architecture for developers and users.

In zkSync Era:

The roles of the Alt Mempool and Bundlers are effectively handled by the regular chain nodes/sequencers.

Every account is fundamentally a smart contract. Even when a user creates an account using a familiar tool like MetaMask (which traditionally generates an EOA), zkSync automatically deploys a default smart contract account implementation for that address.

This default account contract (e.g., DefaultAccount.sol in the matter-labs/era-contracts repository) implements standard interfaces like IAccount and includes functions such as validateTransaction, executeTransaction, and isValidSignature. By default, this contract mimics traditional EOA behavior, validating transactions based on an ECDSA signature from the associated private key.

However, users or developers can override this default implementation by deploying custom smart contract code to their account address. This custom code can then define any arbitrary validation logic, effectively turning any account into a fully programmable smart contract wallet.

The simplified flow on a native AA chain like zkSync might look like this:

Off-Chain: A signer (which could be a traditional private key, a social login mechanism, or a multi-sig scheme) signs the transaction data according to the account's logic.

On-Chain: The signed transaction is sent to zkSync nodes. These nodes natively understand AA and can directly call the validation logic within the user's account contract.

If valid, the transaction is executed by the user's account contract, and the results are included in a block on the zkSync blockchain.

This native approach bypasses the need for a separate Alt Mempool and the EntryPoint.sol contract, as the core protocol itself is designed to handle programmable account validity.

The Future is Abstracted: Enhanced Usability for Web3
Account Abstraction, whether through EIP-4337 on Ethereum or via native implementations on Layer 2s and other blockchains, represents a monumental step towards improving blockchain usability. While the EIP-4337 mechanism on Ethereum involves a complex interplay of off-chain and on-chain components, its goal is to make interacting with Web3 applications as seamless and intuitive as using Web2 applications.

By abstracting away the complexities of private key management and gas payments, AA paves the way for features like social recovery, sponsored transactions, spending limits, and much more. Ultimately, this will lower the barrier to entry, making decentralized technologies more accessible to a broader audience and helping to onboard the next wave of users into the crypto ecosystem.

## What does this repo show?

1. A minimal EVM "Smart Wallet" using alt-mempool AA
   1. We even send a transactoin to the `EntryPoint.sol`
2. A minimal zkSync "Smart Wallet" using native AA
   1. [zkSync uses native AA, which is slightly different than ERC-4337](https://docs.zksync.io/build/developer-reference/account-abstraction.html#iaccount-interface)
   2. We *do* send our zkSync transaction to the alt-mempool

## What does this repo not show?

1. Sending your userop to the alt-mempool 
   1. You can learn how to do this via the [alchemy docs](https://alchemy.com/?a=673c802981)

# Getting Started 

## Requirements

- [git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
  - You'll know you did it right if you can run `git --version` and you see a response like `git version x.x.x`
- [foundry](https://getfoundry.sh/)
  - You'll know you did it right if you can run `forge --version` and you see a response like `forge 0.2.0 (816e00b 2023-03-16T00:05:26.396218Z)`
- [foundry-zksync](https://github.com/matter-labs/foundry-zksync)
  - You'll know you did it right if you can run `forge-zksync --help` and you see `zksync` somewhere in the output

## Installation

```bash
git clone https://github.com/PatrickAlphaC/minimal-account-abstraction
cd minimal-account-abstraction
make
```

# Quickstart 

## Vanilla Foundry

```bash
foundryup
make test
```

### Deploy - Arbitrum

```bash
make deployEth
```

### User operation - Arbitrum

```bash
make sendUserOp
```

## zkSync Foundry

```bash
foundryup-zksync
make zkbuild
make zktest
```

### Deploy - zkSync local network

#### Additional Requirements
- [npx & npm](https://docs.npmjs.com/cli/v10/commands/npm-install)
  - You'll know you did it right if you can run `npm --version` and you see a response like `7.24.0` and `npx --version` and you see a response like `8.1.0`.
- [yarn](https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable)
  - You'll know you did it right if you can run `yarn --version` and you see a response like `1.22.17`.
- [docker](https://docs.docker.com/engine/install/)
  - You'll know you did it right if you can run `docker --version` and you see a response like `Docker version 20.10.7, build f0df350`.
  - Then, you'll want the daemon running, you'll know it's running if you can run `docker --info` and in the output you'll see something like the following to know it's running:
```bash
Client:
 Context:    default
 Debug Mode: false
```

Install dependencies:
```bash
yarn
```

#### Setup - local node

```bash
# Select `in memory node` and nothing else
npx zksync-cli dev start
```

#### Deploy - local node

> [!IMPORTANT]  
> *Never* have a private key associated with real funds in plaintext. 

```bash
# Setup your .env file, see the .env.example for an example
make zkdeploy
```

> Note: Sending an account abstraction transaction doesn't work on the local network, because we don't have the system contracts setup on the local network. 

### Deploy - zkSync Sepolia or Mainnet

Make sure your wallet has at least 0.01 zkSync ETH in it.

1. Encrypt your key 

Add your `PRIVATE_KEY` and `PRIVATE_KEY_PASSWORD` to your `.env` file, then run:

```bash
make encryptKey
```

> [!IMPORTANT]
> NOW DELETE YOUR PRIVATE KEY AND PASSWORD FROM YOUR `.env` FILE!!!
> Don't push your `.encryptedKey.json` up to GitHub either!

1. Un-Comment the Sepolia or Mainnet section (depending on which you'd like to use) of `DeployZkMinimal.ts` and `SendAATx.ts`:

```javascript
// // Sepolia - uncomment to use
```

3. Deploy the contract
```bash
make zkdeploy
```

You'll get an output like:
```
zkMinimalAccount deployed to: 0x4768d649Da9927a8b3842108117eC0ca7Bc6953f
With transaction hash: 0x103f6d894c20620dc632896799960d06ca37e722d20682ca824d428579ba157c
```

Grab the address of the `zkMinimalAccount` and add it to the `ZK_MINIMAL_ADDRESS` of `SendAATx.ts`.

4. Fund your account

Send it `0.002` zkSync sepolia ETH.

5. Send an AA transaction

```bash
make sendTx
```

You'll get an out put like this:

```
Let's do this!
Setting up contract details...
The owner of this minimal account is:  0x643315C9Be056cDEA171F4e7b2222a4ddaB9F88D
Populating transaction...
Signing transaction...
The minimal account nonce before the first tx is 0
Transaction sent from minimal account with hash 0xec7800e3a01d5ba5e472396127b656f7058cdcc5a1bd292b2b49f76aa19548c8
The account's nonce after the first tx is 1
```

# Example Deployments

## zkSync (Sepolia)
- [ZkMinimal Account (Sepolia)](https://sepolia.explorer.zksync.io/address/0xCB38Bdc1527c3F69E13701328546cA6FE23C5691)
- [USDC Approval via native zkSync AA (Sepolia)](https://sepolia.explorer.zksync.io/tx/0x43224b566a0b7497a26c57ab0fcea7d033dccd6cd6e16004523be0ce14fbd0fd)
- [Contract Deployer](https://explorer.zksync.io/address/0x0000000000000000000000000000000000008006)

## Ethereum (Arbitrum)
- [Minimal Account](https://arbiscan.io/address/0x03Ad95a54f02A40180D45D76789C448024145aaF#code)
- [USDC Approval via EntryPoint](https://arbiscan.io/tx/0x03f99078176ace63d36c5d7119f9f1c8a74da61516616c43593162ff34d1154b#eventlog)

# Account Abstraction zkSync Contract Deployment Flow

## First time
1. Calls `createAccount` or `create2Account` on the `CONTRACT_DEPLOYER` system contract 
   1. This will deploy the contract *to the L1*.
   2. Mark the contract hash in the `KnownCodesStorage` contract
   3. Mark it as an AA contract 
   4. [Example](https://sepolia.explorer.zksync.io/tx/0xec0d587903415b2785d542f8b41c21b82ad0613c226a8c83376ec2b8f90ffdd0#eventlog)
      1. Notice 6 logs emitted? 

## Subsequent times
1. Calls `createAccount` or `create2Account` on the `CONTRACT_DEPLOYER` system contract 
   1. The `CONTRACT_DEPLOYER` will check and see it's deployed this hash before
   2. It will put in another system contract that this address is associated with the first has
   3. [Example](https://sepolia.explorer.zksync.io/tx/0xe7a2a895d9854db5a6cc60df60524852d9957dd17adcc5720749f60b4da3eba7)
      1. Only 3 logs emitted!
   
# Acknowledgements 
- [Types of AAs on different chains](https://www.bundlebear.com/factories/all)
- [eth-infinitism](https://github.com/eth-infinitism/account-abstraction/)
- [Dan Nolan](https://www.youtube.com/watch?v=b4KWkIAPa3U)
  - [Twitter Video](https://x.com/BeingDanNolan/status/1795848790043218029)
- [zerodevapp](https://github.com/zerodevapp/kernel/)
- [Alchemy LightAccount](https://github.com/alchemyplatform/light-account/)

# Disclaimer
*This codebase has not undergone a security review.*